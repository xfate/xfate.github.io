<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Xujianming的博客">
    <meta name="keyword"  content="游戏开发">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        unity shader实例3：轮廓渲染-描边 - Xujianming的博客 | Xujianming&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 游戏开发笔记自留地 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Xujianming</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-法线外扩"><span class="toc-text">1.法线外扩</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 游戏开发笔记自留地 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        unity shader实例3：轮廓渲染-描边
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-08-07 00:39:47</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#unity" title="unity">unity</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#shader" title="shader">shader</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#描边" title="描边">描边</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p>本文主要来讲几种描边的实现方法</p>
<h2 id="1-法线外扩"><a href="#1-法线外扩" class="headerlink" title="1.法线外扩"></a>1.法线外扩</h2><pre><code>一般期望的描边效果，就是在模型外面有一圈选边，因此我们可以把模型扩大一点点，利用这个扩大的边缘来实现描边效果。可以看出，扩大的方向其实就是法线的方向，边缘的法线和视线夹角基本成90度。所以我们可以在第一个pass 朝法线方向扩大模型。
要扩大模型，自然是在vertexshader阶段处理，我们实际仅需要扩大边缘，因此我们只需要渲染背面，因为我们第二个pass就会盖在第一个pass的结果上，仅留下扩大的边缘。
</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">				<span class="comment">//把法线转换到视图空间</span></span><br><span class="line"></span><br><span class="line">				float3 vnormal = mul((float3x3)UNITY_MATRIX_IT_MV,v.normal);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//把法线转换到投影空间</span></span><br><span class="line"></span><br><span class="line">				float2 pnormal_xy = mul((float2x2)UNITY_MATRIX_P,vnormal.xy);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//朝法线方向外扩</span></span><br><span class="line"></span><br><span class="line">				o.vertex.xy = o.vertex.xy + pnormal_xy * _Outline;</span><br><span class="line"></span><br><span class="line">```		</span><br><span class="line"></span><br><span class="line">整个代码实现：</span><br></pre></td></tr></table></figure>
<p>Shader “xjm/outline”<br>{<br>    //法线外扩实现描边<br>    Properties<br>    {<br>        _MainTex (“Texture”, 2D) = “white” {}<br>        _Outline(“Outline”,float) = 0.1<br>        _OutlineColor(“OutlineColor”,Color) = (0,0,0,1)<br>    }<br>    SubShader<br>    {<br>        Tags { “RenderType”=”Opaque” }<br>        LOD 100<br>        //描边阶段，法线外扩，渲染背面<br>        Pass<br>        {<br>            //只需要边缘外扩<br>            Cull Front<br>            ZWrite Off<br>            CGPROGRAM</p>
<pre><code>        #pragma vertex vert
        #pragma fragment frag
        struct appdata
        {
            float4 vertex : POSITION;
            float3 normal : NORMAL;
        };
        struct v2f
        {
            float4 vertex : SV_POSITION;
        };
        float _Outline;
        float4 _OutlineColor;            
        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            //把法线转换到视图空间
            float3 vnormal = mul((float3x3)UNITY_MATRIX_IT_MV,v.normal);
            //把法线转换到投影空间
            float2 pnormal_xy = mul((float2x2)UNITY_MATRIX_P,vnormal.xy);
            //朝法线方向外扩
            o.vertex.xy = o.vertex.xy + pnormal_xy * _Outline;
            return o;
        }

        fixed4 frag (v2f i) : SV_Target
        {
            return _OutlineColor;
        }
        ENDCG
    }
    //正常阶段
    Pass
    {

        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv :TEXCOORD0;
        };
        struct v2f
        {
            float4 vertex : SV_POSITION;
            float2 uv:TEXCOORD0;
        };
        sampler2D _MainTex;        
        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = UnityObjectToClipPos(v.vertex);
            o.uv = v.uv;
            return o;
        }    
        fixed4 frag (v2f i) : SV_Target
        {
            return tex2D(_MainTex,i.uv);
        }
        ENDCG
    }
}
</code></pre><p>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实现的效果：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pd1fsftip.bkt.clouddn.com/blog/180807/K9eAAJ47AD.png?imageslim"</span> <span class="attr">witdh</span> = <span class="string">"50%"</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以看得出，除了边缘有被描边之外，里面（模型的前面）也有描边的线条。如何去掉内部的线条呢？可以在第一个pass里关闭深度写入，关闭了深度写入之后，第二个pass就会完全盖住这个模型（除了外扩部分）</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://pd1fsftip.bkt.clouddn.com/blog/180808/3I3H762igi.png?imageslim witdh = "</span><span class="attr">50</span>%"/&gt;</span></span></span><br><span class="line"></span><br><span class="line">但是你再看看在Game视图下描边不起作用了！</span><br><span class="line"></span><br><span class="line">看看FrameDebuger:</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">http://pd1fsftip.bkt.clouddn.com/blog/180808/1aACfklgc4.png?imageslim</span>)</span><br><span class="line"></span><br><span class="line">看到Unity在渲染完模型之后，再渲染了天空盒，因为描边pass没有写入深度，所以被天空盒覆盖了。</span><br><span class="line"></span><br><span class="line">注：Unity的geometry类型的渲染顺序是从前往后的，而Transparent类型是从后往前的。天空盒的渲染顺序位于geometry之后，Transparent之前。因此我们把描边pass放在Transparent的渲染顺序就不会被geometry类型遮挡了。</span><br><span class="line"></span><br><span class="line">因此把渲染队列改成Transparent就可以了。</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">http://pd1fsftip.bkt.clouddn.com/blog/180808/4983FJK5Ki.png?imageslim</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## 后处理实现描边效果</span></span><br><span class="line"></span><br><span class="line">​	法线外扩的方法有一个缺点，就是当模型边缘比较菱角分明的时候，法线外扩后会出现不连续的现象。因此我们还可以用后处理来实现描边或者外发光的效果。</span><br><span class="line"></span><br><span class="line">​	想象一下，我们要实现描边，按法线外扩的做法，是在渲染正常画面之前先渲染了一张比模型边缘扩大了一点点的纯色图片。再用正常的渲染模型盖住纯色模型，只让纯色图片的外扩的边缘显示出来。</span><br><span class="line"></span><br><span class="line">​	在后处理阶段要怎么处理呢？</span><br><span class="line"></span><br><span class="line"><span class="section">### 处理流程</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>我们可以在OnPreRender函数里先渲染一张纯色照片。OnPreRender函数在渲染之间执行。在正常渲染之间，我们先用一个纯色shader 替换要描边物体的shader，把渲染出来的纯色图片渲染到纹理上。</span><br><span class="line"><span class="bullet">2. </span>怎么把这张纯色照片的边缘外扩的呢? 可以选择模糊的方法。高斯模糊的具体实现在这里就不多说了。我们模糊了之后的照片，边缘就会往外扩散。</span><br><span class="line"><span class="bullet">3. </span>得到模糊的照片后，我们用模糊照片的颜色减去纯色照片的颜色，就会得到一个边缘照片。</span><br><span class="line"><span class="bullet">4. </span>用正常渲染的图，叠加边缘图片就可以得到一个外发光或者描边的效果了。</span><br><span class="line"></span><br><span class="line"><span class="code">	### 2.1 普通后处理实现</span></span><br><span class="line"></span><br><span class="line"><span class="code">		上面的4个流程中，在Unity5之前，我们可以额外增加一个摄像机，摄像机只渲染要描边的物体。而这个摄像机渲染到RenderTexture上。这个摄像机用来渲染纯色图片。</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">		仅渲染Player 层，创建一个RenderTexture</span></span><br></pre></td></tr></table></figure>
<pre><code>m_outlineCamera.cullingMask = 1 &lt;&lt; LayerMask.NameToLayer(&quot;Player&quot;);
int width = m_outlineCamera.pixelWidth &gt;&gt; m_downSampler;
int height = m_outlineCamera.pixelHeight &gt;&gt; m_downSampler;
m_renderTexture = RenderTexture.GetTemporary(width, height, 0);
</code></pre><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在渲染之间，用RenderWithShader函数替换<span class="built_in">shader</span>。这里的意思是在此刻，OutlineCamera摄像机下的所有物体都用outlineShader渲染。</span><br></pre></td></tr></table></figure>
<p>  private void OnPreRender()<br>    {<br>        //先渲染到RT<br>        if (m_outlineCamera.enabled)<br>        {<br>            m_outlineCamera.targetTexture = m_renderTexture;<br>            m_outlineCamera.RenderWithShader(m_outlinePreShader, “”);//渲染了一张纯色RT<br>        }<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">渲染完后，在OnRenderImage阶段：</span><br></pre></td></tr></table></figure>
<p> private void OnRenderImage(RenderTexture source, RenderTexture destination)<br>    {<br>        int rtW = source.width &gt;&gt; m_downSampler;<br>        int rtH = source.height &gt;&gt; m_downSampler;<br>        var temp1 = RenderTexture.GetTemporary(rtW, rtH, 0);<br>        var temp2 = RenderTexture.GetTemporary(rtW, rtH, 0);<br>        // 先模糊纯色的图片<br>        Graphics.Blit(m_renderTexture, temp1);<br>        // 模糊迭代<br>        for (int i = 0; i &lt; blurIterator; ++i)<br>        {<br>            Graphics.Blit(temp1, temp2, outlineMaterial, 0);<br>            Graphics.Blit(temp2, temp1, outlineMaterial, 1);<br>        }<br>        if (hardSide)<br>        {<br>            outlineMaterial.EnableKeyword(“_Hard_Side”);<br>        }<br>        else<br>        {<br>            outlineMaterial.DisableKeyword(“_Hard_Side”);<br>        }</p>
<pre><code>    outlineMaterial.SetTexture(&quot;_BlurTex&quot;, temp2);
    outlineMaterial.SetTexture(&quot;_SrcTex&quot;, m_renderTexture);
    outlineMaterial.SetColor(&quot;_OutlineColor&quot;, outlineColor);
    Graphics.Blit(source, destination, outlineMaterial, 2);
    RenderTexture.ReleaseTemporary(temp1);
    RenderTexture.ReleaseTemporary(temp2);
}
</code></pre><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">来看看<span class="keyword">shader部分：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>	纯色<span class="keyword">shader, </span>就返回一个边缘色就行了。非常简单</span><br></pre></td></tr></table></figure>
<p>CGPROGRAM</p>
<pre><code>#pragma vertex vert
#pragma fragment frag

float4 _OutlineColor;
struct appdata
{
    float4 vertex : POSITION;
};

struct v2f
{
    float4 vertex : SV_POSITION;
};


v2f vert (appdata v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    return o;
}

fixed4 frag (v2f i) : SV_Target
{
    return _OutlineColor;
}
ENDCG
</code></pre><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​	描边<span class="string">shader:</span></span><br></pre></td></tr></table></figure>
<p>/// Upgrade NOTE: replaced ‘mul(UNITY_MATRIX_MVP,<em>)’ with ‘UnityObjectToClipPos(</em>)’</p>
<p>Shader “xjm/outline_postEffect”<br>{<br>    Properties<br>    {<br>        _MainTex (“Texture”, 2D) = “white” {}<br>        _BlurSize(“Blur Size”,float) = 1<br>        _BlurTex(“Blur Tex”,2D) = “”{}<br>        _SrcTex(“SrcTex”, 2D) = “white”{}<br>        _OutlineColor(“OutLine Color”,Color) = (1,1,1,1)<br>    }<br>    CGINCLUDE</p>
<pre><code>#include &quot;UnityCG.cginc&quot;
uniform half4 _MainTex_TexelSize;
// 边缘分成了硬边和软边两种。
#pragma shader_feature _Hard_Side 
float _BlurSize;    
sampler2D _MainTex;
sampler2D _BlurTex;
sampler2D _SrcTex;
float4 _OutlineColor;
// 高斯模糊部分 ---{
//高斯模糊权重
static const half4 GaussWeight[7] =
{
    half4(0.0205,0.0205,0.0205,0),
    half4(0.0855,0.0855,0.0855,0),
    half4(0.232,0.232,0.232,0),
    half4(0.324,0.324,0.324,1),
    half4(0.232,0.232,0.232,0),
    half4(0.0855,0.0855,0.0855,0),
    half4(0.0205,0.0205,0.0205,0)
};


struct v2f_Blur
{
    float4 pos:SV_POSITION;
    half2 uv:TEXCOORD0;
    half2 offset:TEXCOORD1;
};
// 水平方向的高斯模糊
v2f_Blur vert_blur_Horizonal(appdata_img v)
{
    v2f_Blur o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    o.offset = _MainTex_TexelSize.xy * half2(1,0)*_BlurSize;
    return o;
}
// 垂直方向的高斯模糊
v2f_Blur vert_blur_Vertical(appdata_img v)
{
    v2f_Blur o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;

    o.offset = _MainTex_TexelSize.xy * half2(0,1)*_BlurSize;
    return o;
}
half4 frag_blur(v2f_Blur i):COLOR
{
    half2 uv_withOffset = i.uv - i.offset * 3;
    half4 color = 0;
    for (int j = 0; j &lt; 7; ++j)
    {
        half4 texcol = tex2D(_MainTex,uv_withOffset);
        color += texcol * GaussWeight[j];
        uv_withOffset += i.offset;
    }
    return color;
}
// }--- 高斯模糊部分
//add
struct v2f_add
{
    float4 pos : SV_POSITION;
    float2 uv  : TEXCOORD0;
    float2 uv1 : TEXCOORD1;
};
v2f_add vert_add(appdata_img v)
{
    v2f_add o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    o.uv1 = o.uv;
</code></pre><p>#if UNITY_UV_STARTS_AT_TOP<br>            o.uv.y = 1- o.uv.y;</p>
<p>#endif<br>        return o;<br>    }<br>    half4 frag_add(v2f_add i):COLOR<br>    {<br>        //获取屏幕<br>        fixed4 scene = tex2D(_MainTex, i.uv1);<br>        fixed4 blurCol = tex2D(_BlurTex,i.uv1);<br>        fixed4 srcCol = tex2D(_SrcTex,i.uv1);</p>
<pre><code>    #if _Hard_Side 
        // 如果是硬边描边，就用模糊纹理-原来的纹理得到边缘
        fixed4 outlineColor = saturate(blurCol - srcCol);
        // all(outlineColor.rgb) 三个分量都不等于0，返回1，否则返回0.类似&amp;&amp;运算
        // any(outlineColor.rgb);rgb 任意不为 0，则返回 true。类似||运算
        // 如果rgb都不为0(硬边部分）就显示硬边，否则都显示scene部分。
        return scene * (1 - all(outlineColor.rgb))  +  _OutlineColor * any(outlineColor.rgb);
    #else
        return saturate(blurCol - srcCol) + scene;
    #endif



}

//add
ENDCG
SubShader
{

    ZTest Always

        ZWrite Off
        Fog{ Mode Off }

    //0
    Pass 
    {
        ZTest Always
        Cull Off
        CGPROGRAM
        #pragma vertex vert_blur_Horizonal
        #pragma fragment frag_blur
        ENDCG
    }
    //1
    Pass
    {
        ZTest Always
        Cull Off
        CGPROGRAM
        #pragma vertex vert_blur_Vertical
        #pragma fragment frag_blur
        ENDCG
    }
    //2
    Pass
    {
        ZTest Off
        Cull Off

        CGPROGRAM
        #pragma vertex vert_add
        #pragma fragment frag_add
        ENDCG
    }

}
</code></pre><p>}</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">软边（外发光）：</span><br><span class="line"></span><br><span class="line">Pass0 和Pass1 分别是水平和垂直方向的模糊，在Pass 2 里进行相减。</span><br><span class="line"></span><br><span class="line">blurCol - srcCol 后的图像是这样子的</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">http://pd1fsftip.bkt.clouddn.com/blog/180809/KadKDhmCIa.png?imageslim</span>)</span><br><span class="line"></span><br><span class="line">再叠加正常图像，可以得到：</span><br><span class="line"></span><br><span class="line">得到外发光的描边。</span><br><span class="line"></span><br><span class="line">saturate(blurCol - srcCol) + scene;</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">http://pd1fsftip.bkt.clouddn.com/blog/180809/d6G2ec0D8d.png?imageslim</span>)	</span><br><span class="line"></span><br><span class="line">要实现硬边的效果，还在再处理一下，由上面那张相减之后的图片可以看到边缘是一个渐变的过程。边缘色越外越接近黑色RGB(0,0,0)。因此我们只选取RGB都大于0的部分像素就可以剔除渐变部分，只留下硬边部分。</span><br><span class="line"></span><br><span class="line"> saturate(blurCol - srcCol); 把结果限制为[0,1]，因为相减可能会导致负值，从而描边在模型内部染色。</span><br></pre></td></tr></table></figure>
<p>// 如果是硬边描边，就用模糊纹理-原来的纹理得到边缘<br>            fixed4 outlineColor = saturate(blurCol - srcCol);<br>            // all(outlineColor.rgb) 三个分量都不等于0，返回1，否则返回0.类似&amp;&amp;运算<br>            // any(outlineColor.rgb);rgb 任意不为 0，则返回 true。类似||运算<br>            // 如果rgb都大于0(硬边部分）就显示硬边，否则都显示scene部分。<br>            return scene <em> (1 - all(outlineColor.rgb))  +  _OutlineColor </em> any(outlineColor.rgb);<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![<span class="string">mark</span>](<span class="link">http://pd1fsftip.bkt.clouddn.com/blog/180809/acc3Hb1dHH.png?imageslim</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 2.2 Command Buffer 实现</span></span><br><span class="line"></span><br><span class="line">​	除了用额外的摄像机之外，在Unity5 还可以用Command Buffer来实现，代码会更简单。</span><br><span class="line"></span><br><span class="line">因为Command Buffer 可以在RenderImage 里执行。所以可以在初始化的时候，设置Command Buffer的renderTexture，设置要描边物体的shader。然后在后处理的时候再执行这个Command。就可以得到纯色图像了。</span><br><span class="line"></span><br><span class="line">​	初始化部分：</span><br></pre></td></tr></table></figure></p>
<p>m_commandBuffer = new CommandBuffer();<br>        if (m_renderTexture == null)<br>            m_renderTexture = RenderTexture.GetTemporary(Screen.width &gt;&gt; m_downSampler, Screen.height &gt;&gt; m_downSampler, 0);<br>        m_commandBuffer.SetRenderTarget(m_renderTexture);<br>        m_commandBuffer.ClearRenderTarget(true, true, Color.black);<br>        foreach (var renderer in Renderers)<br>        {<br>            m_commandBuffer.DrawRenderer(renderer, outlinePreMaterial)<br>        }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​	在后处理阶段：</span><br></pre></td></tr></table></figure></p>
<p> int rtW = source.width &gt;&gt; m_downSampler;<br>        int rtH = source.height &gt;&gt; m_downSampler;</p>
<pre><code>    // 插入commandbuffer，绘制出纯色的图片
    m_outlinePreMat.SetColor(&quot;_OutlineColor&quot;, outlineColor);
    Graphics.ExecuteCommandBuffer(m_commandBuffer);
    var temp1 = RenderTexture.GetTemporary(rtW, rtH, 16);
    var temp2 = RenderTexture.GetTemporary(rtW, rtH, 16);
    Graphics.Blit(m_renderTexture, temp1, outlineMaterial, 0);
    Graphics.Blit(temp1, temp2, outlineMaterial, 1);
    for (int i = 0; i &lt; blurIterator; ++i)
    {
        Graphics.Blit(temp2, temp1, outlineMaterial, 0);
        Graphics.Blit(temp1, temp2, outlineMaterial, 1);
    }
    if (onlyShowBlur)
    {
        Graphics.Blit(temp2, destination);
        RenderTexture.ReleaseTemporary(temp1);
        RenderTexture.ReleaseTemporary(temp2);
        return;
    }
    //add
    //把模糊的边框加到原来的照片中
    if (hardSide)
    {
        outlineMaterial.EnableKeyword(&quot;_Hard_Side&quot;);
        outlineMaterial.SetColor(&quot;_OutlineColor&quot;, outlineColor);
    }
    else
    {
        outlineMaterial.DisableKeyword(&quot;_Hard_Side&quot;);
    }
    outlineMaterial.SetTexture(&quot;_BlurTex&quot;, temp2);
    outlineMaterial.SetTexture(&quot;_SrcTex&quot;, m_renderTexture);
    outlineMaterial.SetFloat(&quot;_BlurSize&quot;, blurSize);
    Graphics.Blit(source, destination, outlineMaterial, 2);
    RenderTexture.ReleaseTemporary(temp1);
    RenderTexture.ReleaseTemporary(temp2);
}
</code></pre><p><code>`</code></p>
<p>​    不用额外增加camera，非常方便。</p>
<p>​    </p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/xfate">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'unity shader实例3：轮廓渲染-描边',
        owner: 'aircloud',
        repo: 'hexo-aircloud-blog',
        oauth: {
            client_id: 'your-id-created-by-https://github.com/settings/applications/new',
            client_secret: 'your-secret-created-by-https://github.com/settings/applications/new',
        },
    })
    gitment.render('comment-container')
</script>

</html>
